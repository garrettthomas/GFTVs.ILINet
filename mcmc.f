      subroutine mcmc(simdat,ndays,nparam,
     $     dt,nstep,nsamps,logbase,pmax,pmin,ilog,
     $     step,imask,pval,ithin,iseed,
     $     solbest,tab)

      implicit real*8(a-h,o-z)
      
      real*8 simdat(ndays)
      real*8 solbest(ndays),rtn(ndays)
      integer logbase,nstep,ndays,ithin
      integer nparam,Nproxy,ilog(nparam),imask(nparam),iseed
      integer iaccept_vec(nparam),iverborse
      real*8 dt
      real*8 pmax(nparam),pmin(nparam),pval(nparam)
      real*8 step(nparam),curpars(nparam),savepar(nparam)
      real*8 parupdt(nparam),copypar(nparam)
      real*8 savestep(nparam)
      real*8 solinit(ndays),solnew(ndays)
      logical plog(nparam),accept,verborse
      real*8 tab(nsamps/ithin,(nparam+1))
      real rand


! initialize the random number generator
      call srand(iseed)

! Number of MCMC steps is number of samples times number of parameters
      nMcMc = nparam * nsamps

! convert 0 and 1 to true and false

      do i=1,nparam
         if (ilog(i) .eq. 0) Then
            plog(i) = .false.
         else
            plog(i) = .true.
         endif
      enddo

! this controls the amount of printing
         verborse=.false.
!      verborse=.true.
           
      savestep = step
      
      icount = 0

      curpars = pval
      solinit = 0.0d0

! solinit will hold the initial model solution

      CALL PROP(simdat,dt,nstep,ndays,
     $          curpars,nparam,curLLK,solinit)

      curMin = curLLK
      solbest=solinit
      
      if (verborse) call dblepr("initial LLK",-1,curMin,1)

      iaccept = 0
           
      do i =1,nsamps
 
         savepar = curpars
         copypar = curpars
              
!     Propose a new value for each parameter we are optimizing 
! half the steps will be small and half will be large
         rnd = rand(0)
         if (rnd. le. 0.5) Then
            step = savestep
         else
            step = savestep/10.0d0
         endif
         call fnProposeParamUpdates(nparam,copypar,pmin,
     $        pmax,step,logbase,plog,imask,parupdt)
               
! update all the parameters and calculate a new solution and LLK

         curpars = parupdt

         solnew = 0.0d0

         CALL PROP(simdat,dt,nstep,
     $        ndays,curpars,nparam,fnewLLK,solnew)

         diff_like = fnewLLK - curLLK

         accept = .false.
         if (diff_like .lt. 0.0d0) Then
            accept = .true.
         endif
         
         if (diff_like .ge. 0.0d0) Then
            rnd = dble(rand(0))
            if (exp(-diff_like) .gt.rnd) Then
               accept = .true.
            else
               accept = .false.
            endif                 
         endif
            
! if step is accepted 

         if (accept) Then
            iaccept = iaccept + 1
            
            savepar = curpars
            
            curLLK = fnewLLK
            if (curLLK .le. curMin) then !keep track of the best profile we have
               solbest=solnew
            endif
!     if step is rejected - restore saved values of parameters
         else
            
            curpars = savepar

         endif
            
!update change information only every ithin iterations 
               
         if (mod(i,ithin) .eq. 0) Then
            icount = icount + 1
            tab(icount,1:nparam)   = curpars
            tab(icount,(nparam+1)) = curLLK
            
            if (verborse .and. mod(i,ithin*100).eq. 0)  
     $           call dblepr('curLLK',-1,curLLK,1)
            
         endif

      enddo                     ! end of loop on nMCMC for one chain
      accept_rate = dble(iaccept)/dble(nsamps) *100.0d0
      if (verborse) Then
         call dblepr('acceptence %',-1,accept_rate,1)
         
      endif

      pval = curpars
                  
      return
      end subroutine mcmc

c##############################################################################
      subroutine prop(y,dt,nstep,ndays,
     $           param,nparam,chi2,x)
      
C In this version the parameters are: beta0, pC, Tg,seed, Neff and Timeshift
C Neff is fixed
	
	implicit real*8(a-h,o-z)

	real*8 dt, param(nparam)
! Param holds all the parameters

	integer ndays,nstep,nparam
	real*8 y(ndays),x(ndays)

! Y has in it the incidence data, x is generated by the SIR model
	real*8 x0(4)
	real*8 dsdt(ndays*nstep)
	real*8 chi2, calcFit
	external CalcFit

	beta0 = param(1)
	pC = param(2)
        Tg = param(3)
        seed = param(4)
	fNeff = param(5)

! Initial values for S(0), I(0), R(0) and -dS(0)/dt
! For both populations

	x0(2) =1.          !I(0) 
	
        S0 = fNeff - x0(2)

	x0(1) = S0          !S(0)
	x0(3) = 0.0d0       !R(0) 
	x0(4) = 0.0d0       !-ds/dt 
	
! Here we must call the RK4 routine and calculate the model prediction for incidence rate
        dsdt = 0.0d0
	call RK4(dt,ndays,nstep,x0,Param,nparam,dsdt)
           
!  Now convert to one day bins and multiply by pC and add the baseline

	call daily(ndays,nstep,dsdt,x,pC,seed)

! Nowe we can calculate the -LLK

	chi2 = calcFit(y,x,ndays)  

	return
	end subroutine prop



c----------------------------------------------------------------

      function SR_to_unit(y,ymin,ymax,logbase,logflag)

      implicit real*8 (a-h,o-z)
      real*8 y, ymin,ymax,rtn,SR_to_Unit
      integer logbase
      logical logflag

      if (logflag) Then
         if (logbase .eq. 10) Then
            rtn = (log10(y) - log10(ymin)) /
     $            (log10(ymax)-log10(ymin))
         else
            rtn = (log(y) - log(ymin)) /
     $            (log(ymax)-log(ymin))
         endif
      else
         rtn = (y - ymin)/(ymax - ymin)
      endif

      SR_to_unit = rtn
 
      return
      end function SR_to_unit

c----------------------------------------------------------------

      function SR_from_unit(x,ymin,ymax,logbase,logflag)
      
      implicit real*8(a-h,o-z)
      
      real*8 x,ymin,ymax,rtn,SR_from_unit
      integer logbase
      logical logflag


      if (logflag) Then
         if (logbase .eq. 10) Then
            rtn = ymin * 
     $           10.0**(x*(log10(ymax)-log10(ymin)))
         else
            rtn = ymin * exp(x*(log(ymax)-log(ymin)))
         endif

      else
         rtn = ymin + (ymax-ymin)*x
      endif

      SR_from_unit = rtn

      return
      end function SR_from_unit

c----------------------------------------------------------------

      subroutine fnProposeParamUpdates(nparam,curval,valmin,
     $     valmax,step,logbase,logflag,imask,parupdt)

      implicit real*8(a-h,o-z)
      real*8 curval(nparam),valmin(nparam),valmax(nparam)
      real*8 parupdt(nparam),step(nparam)
      real*8 x, rv
      real rand
      integer logbase,imask(nparam)
      logical logflag(nparam) 
      external SR_to_unit, SR_from_unit

       do i = 1, nparam 

          parupdt(i)=curval(i)
          if (imask(i) .lt. 0) go to 101 ! Propose a new value ONLY if parameter is optimized

          rv = dble(rand(0))

          rv = (rv - 0.50d0)*step(i)


! convert to a zero - one scale

          x = SR_to_unit(curval(i),valmin(i),valmax(i),
     $         logbase,logflag(i))

          x = x + rv

! periodic boundary conditions 

          if (x .lt. 0.0d0) x = 1.0d0 + x
          if (x .gt. 1.0d0) x = x - 1.0d0

! check to see value does not exceed allowed zero to one range

         if (x .lt. 0.0d0 .or. x .gt. 1.0d0) then

            call dblepr('Problem in fnProposeParamUpdates',
     $           -1,x,1)

            return
         endif

! bring value back to original scale
      
         rtn = SR_from_unit(x,valmin(i),valmax(i),
     $        logbase,logflag(i))

         parupdt(i) = rtn
         
 101     continue
      enddo

      return
      end subroutine fnProposeParamUpdates

!----------------------------------------------------------------

      function fnProposeParamUpdatesSingle(curval,valmin,valmax,
     $     step,logbase,logflag)

      implicit real*8(a-h,o-z)
      real*8 curval,valmin,valmax,step,temp(3)
      integer logbase,iseed
      logical logflag
      real rand
      external SR_to_unit
 
      rv = dble(rand(0))

      rv = (rv - 0.50d0)*step

      x = curval 

      x = SR_to_unit(curval,valmin,valmax,logbase,logflag)

      x = x + rv

      if (x .lt. 0.0d0) x = 1.0d0 + x
      if (x .gt. 1.0d0) x = x - 1.0d0


      if (x .lt. 0.0d0 .or. x .gt. 1.0d0) then
         call dblepr('Problem in fnProposeParamUpdatesSingle',-1,
     $        x,1)
         return
      endif
      
      rtn = SR_from_unit(x,valmin,valmax,logbase,logflag)

      fnProposeParamUpdatesSingle = rtn

      return
      end function fnProposeParamUpdatesSingle

!---------------------------------------------------------------------------------

!----------------------------------------------------------------------

      SUBROUTINE RK4(dt, nweeks,nstep,Y,Param,nparam,
     $  dsdt,Rvec)

      implicit real*8(a-h,o-z)

      integer nweeks, nstep
      REAL*8 dt, Y(4), Param(nparam),tmpY(4)
      real*8 shdat(nweeks),schooldat(nweeks)
      real*8 param3(3)
      REAL*8 dPop1(4), dPop2(4), dPop3(4), dPop4(4)
      Real*8 SIR(nweeks,4),dsdt(nstep*nweeks)
      real*8 Rvec(nweeks)

C
C     Integrates the equations one step, using Runge-Kutta 4 
C     Note: we work with arrays rather than variables to make the
C     coding easier
C

  R0min = param(1)
	deltaR = param(2)
	aparam = param(3)
	pC = param(4)
	seed = param(5)
	Tg = param(6)
	fNeff = param(7)
	timeshift = param(8)
	alpha = param(9)
	delta = param(10)
	ts    = param(11)
	dur   = param(12)

	param3(1) = R0min/Tg
	param3(2) = Tg
	param3(3) = fNeff

      do iweek = 1, nweeks
! Update information

         do j=1,4
            SIR(iweek,j)=Y(j)
         enddo

! calculate R(t) for this week-and then convert to beta(t)

	 param3(1) = (R0min+deltaR*exp(-aparam*shdat(iweek)))
     $               *(1.0d0-alpha*schooldat(iweek))

	 if (iweek >= ts .and. iweek <= (ts+dur)) Then
	    param3(1) = param3(1) * (1.0d0+delta)
	 endif

! convert to beta(t)
         param3(1) = param3(1) / Tg


         do istep = 1, nstep

            call diff(Param3,Y,dpop1)

            do k=1,4
               tmpY(k)=Y(k)+dt*dPop1(k)/2.0
            ENDDO 
         
            call diff(Param3,tmpY,dpop2)

            do k=1,4
               tmpY(k)=Y(k)+dt*dPop2(k)/2.0
            ENDDO

            call diff(Param3,tmpY,dpop3)

            do k=1,4
               tmpY(k)=Y(k)+dt*dPop3(k)
            ENDDO

            call diff(Param3,tmpY,dpop4)

            do k=1,4
               tmpY(k)=Y(k)+dt*(dPop1(k)/6.0 + dPop2(k)/3.0 +
     $              dPop3(k)/3.0 + dPop4(k)/6.0)
               Y(k) = tmpY(k)
            ENDDO

!     Update -dS/dt
            dsdt(istep+(iweek-1)*nstep) = y(4)
	 enddo

      enddo
      RETURN
      END

!------------------------------------
C The Main Differential Equations.

      SUBROUTINE Diff(Param, Pop, dPop)

      implicit real*8(a-h,o-z)

      REAL*8 Param(3), Pop(4), dPop(4)

C
C     The differential equations-including source/sink term
C

C     dS/dt =
      dPop(1) = - Param(1)*Pop(1)*Pop(2)/Param(3)
C     dI/dt =
      dPop(2) =   Param(1)*Pop(1)*Pop(2)/Param(3)
     $          - Pop(2)/Param(2)
C     dR/dt =
      dPop(3) =   Pop(2)/Param(2) 
c cummulative dsdt
      dPop(4) = Param(1)*Pop(1)*Pop(2)/Param(3)
      RETURN
      END

!--------------------------------------------------------------------------------
           
        subroutine daily(iday,nstep,dsdt,x,pC,seed)
        
        implicit real*8(a-h,o-z)
        integer iday,nstep
        real*8 dsdt(iday*nstep),x(iday)

        do i=1,iday
           x(i) = dsdt(i*nstep) - dsdt(1+(i-1)*nstep)
        enddo
	x= x* pC +seed
        return
        end subroutine daily

!---------------------------------------------------------------------------------

        function calcFit(y,x,iday)

        implicit real*8(a-h,o-z)

        integer iday,istart,iend
        real*8 y(iday),x(iday)
        real*8 xi, yi,sum,val,CalcFit


c x is the simulated data
c y is the base profile


C calculate the P(yi,xi)
        sum = 0.0
        do i=1,iday

           yi = y(i)
           xi = x(i)

           val = yi * log(xi) - xi - dlgama(yi+1.0)
           sum = sum + val 

        enddo
        sum = -sum   
        
        CalcFit = sum

        return
        end function CalcFit
